# Минимальная версия CMake
cmake_minimum_required(VERSION 3.14)

# Название проекта
project(My3DModelViewer)

# Установка стандарта C++17
set(CMAKE_CXX_STANDARD 17)

# Включение автоматической генерации MOC, RCC и UIC
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# Поиск и подключение необходимых модулей Qt6
find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets)

# Список исходных файлов
set(SOURCES
    main.cpp
    model.cpp
    viewer.cpp
    modelviewer.cpp
    mainwindow.cpp
)

# Список заголовочных файлов
set(HEADERS
    model.h
    viewer.h
    modelviewer.h
    mainwindow.h
)

# Создание исполняемого файла с указанием исходных и заголовочных файлов
add_executable(My3DModelViewer
    ${SOURCES}
    ${HEADERS}
)

# Подключение библиотек Qt6 к проекту
target_link_libraries(My3DModelViewer PRIVATE Qt6::Core Qt6::Gui Qt6::Widgets)

1. main.cpp
#include <QApplication>  // Основной класс приложения Qt
#include "mainwindow.h"  // Заголовочный файл главного окна

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);  // Создание объекта приложения
    MainWindow window;             // Создание объекта главного окна
    window.show();                 // Отображение главного окна
    return app.exec();             // Запуск основного цикла приложения
}


2. mainwindow.cpp
#include "mainwindow.h"
#include <QMenuBar>
#include <QMenu>
#include <QAction>
#include <QFileDialog>
#include <QMessageBox>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), modelViewer(new ModelViewer(this))
{
    setWindowTitle("3D Model Viewer");
    setCentralWidget(modelViewer);

    QMenu *fileMenu = menuBar()->addMenu("Файл");
    QAction *openAction = fileMenu->addAction("Открыть");
    connect(openAction, &QAction::triggered, this, &MainWindow::openModel);
}

MainWindow::~MainWindow() {}

void MainWindow::openModel()
{
    QString filePath = QFileDialog::getOpenFileName(this, "Открыть модель", "", "OBJ Files (*.obj)");

    if (!filePath.isEmpty()) {
        if (modelViewer->loadModel(filePath)) {
            // Получаем данные о модели через методы ModelViewer
            QVector3D dimensions = modelViewer->getModelDimensions();
            double volume = modelViewer->calculateVolume();
            double area = modelViewer->calculateProjectionArea();

            // Обновляем заголовок окна с информацией о модели
            QString title = QString("3D Model Viewer | Размеры: %1x%2x%3 м | Объем: %4 м³ | Площадь проекции: %5 м²")
                            .arg(dimensions.x(), 0, 'f', 2)
                            .arg(dimensions.y(), 0, 'f', 2)
                            .arg(dimensions.z(), 0, 'f', 2)
                            .arg(volume, 0, 'f', 2)
                            .arg(area, 0, 'f', 2);
            setWindowTitle(title);
        } else {
            QMessageBox::warning(this, "Ошибка", "Не удалось загрузить модель.");
        }
    } else {
        QMessageBox::warning(this, "Предупреждение", "Файл не выбран.");
    }
}


2.1 mainwindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include "modelviewer.h"

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void openModel();

private:
    ModelViewer *modelViewer;
};

#endif // MAINWINDOW_H


3. model.cpp
#include "model.h"
#include <QFile>
#include <QTextStream>
#include <cmath>

Model::Model() {}

bool Model::load(const QString &filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return false;

    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine();
        QStringList parts = line.split(" ", Qt::SkipEmptyParts);
        if (parts.isEmpty()) continue;

        if (parts[0] == "v") {
            float x = parts[1].toFloat() / 1000.0f; // Перевод из мм в м
            float y = parts[2].toFloat() / 1000.0f;
            float z = parts[3].toFloat() / 1000.0f;
            vertices.append(QVector3D(x, y, z));
        } else if (parts[0] == "f") {
            QVector<int> face;
            for (int i = 1; i < parts.size(); ++i) {
                face.append(parts[i].split("/")[0].toInt() - 1);
            }
            faces.append(face);
        }
    }

    file.close();
    return true;
}

double Model::calculateVolume() const {
    double volume = 0.0;
    for (const QVector<int> &face : faces) {
        if (face.size() < 3) continue;
        const QVector3D &v0 = vertices[face[0]];
        const QVector3D &v1 = vertices[face[1]];
        const QVector3D &v2 = vertices[face[2]];
        volume += v0.x() * v1.y() * v2.z() + v1.x() * v2.y() * v0.z() + v2.x() * v0.y() * v1.z()
                - v0.z() * v1.y() * v2.x() - v1.z() * v2.y() * v0.x() - v2.z() * v0.y() * v1.x();
    }
    return std::abs(volume) / 6.0;
}

double Model::calculateProjectionArea() const {
    double area = 0.0;
    for (const QVector<int> &face : faces) {
        if (face.size() < 3) continue;
        const QVector3D &v0 = vertices[face[0]];
        const QVector3D &v1 = vertices[face[1]];
        const QVector3D &v2 = vertices[face[2]];
        area += std::abs((v1.x() - v0.x()) * (v2.y() - v0.y()) - (v2.x() - v0.x()) * (v1.y() - v0.y())) / 2.0;
    }
    return area;
}

QVector3D Model::getModelDimensions() const {
    if (vertices.isEmpty()) return QVector3D(0, 0, 0);

    float minX = vertices[0].x(), maxX = vertices[0].x();
    float minY = vertices[0].y(), maxY = vertices[0].y();
    float minZ = vertices[0].z(), maxZ = vertices[0].z();

    for (const QVector3D &vertex : vertices) {
        if (vertex.x() < minX) minX = vertex.x();
        if (vertex.x() > maxX) maxX = vertex.x();
        if (vertex.y() < minY) minY = vertex.y();
        if (vertex.y() > maxY) maxY = vertex.y();
        if (vertex.z() < minZ) minZ = vertex.z();
        if (vertex.z() > maxZ) maxZ = vertex.z();
    }

    return QVector3D(maxX - minX, maxY - minY, maxZ - minZ);
}

const QVector<QVector3D>& Model::getVertices() const {
    return vertices;
}

const QVector<QVector<int>>& Model::getFaces() const {
    return faces;
}

void Model::rotateX(float angle) {
    float rad = qDegreesToRadians(angle);
    for (QVector3D &vertex : vertices) {
        float y = vertex.y() * cos(rad) - vertex.z() * sin(rad);
        float z = vertex.y() * sin(rad) + vertex.z() * cos(rad);
        vertex.setY(y);
        vertex.setZ(z);
    }
}

void Model::rotateY(float angle) {
    float rad = qDegreesToRadians(angle);
    for (QVector3D &vertex : vertices) {
        float x = vertex.x() * cos(rad) + vertex.z() * sin(rad);
        float z = -vertex.x() * sin(rad) + vertex.z() * cos(rad);
        vertex.setX(x);
        vertex.setZ(z);
    }
}

void Model::rotateZ(float angle) {
    float rad = qDegreesToRadians(angle);
    for (QVector3D &vertex : vertices) {
        float x = vertex.x() * cos(rad) - vertex.y() * sin(rad);
        float y = vertex.x() * sin(rad) + vertex.y() * cos(rad);
        vertex.setX(x);
        vertex.setY(y);
    }
}



3.1 model.h
#ifndef MODEL_H
#define MODEL_H

#include <QVector>
#include <QVector3D>

class Model
{
public:
    Model();
    bool load(const QString &filePath);
    double calculateVolume() const;
    double calculateProjectionArea() const;
    QVector3D getModelDimensions() const; // Новый метод для получения размеров модели

    const QVector<QVector3D>& getVertices() const;
    const QVector<QVector<int>>& getFaces() const;

    void rotateX(float angle);
    void rotateY(float angle);
    void rotateZ(float angle);

private:
    QVector<QVector3D> vertices;
    QVector<QVector<int>> faces;
};

#endif // MODEL_H



4. modelviewer.cpp
#include "modelviewer.h"
#include <QVBoxLayout>
#include <QFileDialog>
#include <QMessageBox>

ModelViewer::ModelViewer(QWidget *parent)
    : QWidget(parent), model(new Model()), viewer(new Viewer(this))
{
    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(viewer);
    setLayout(layout);
}

bool ModelViewer::loadModel(const QString &filePath)
{
    if (model->load(filePath)) {
        viewer->setModel(model);
        // Автоматическое масштабирование при загрузке модели
        QVector3D dimensions = model->getModelDimensions();
        float maxDimension = qMax(dimensions.x(), qMax(dimensions.y(), dimensions.z()));
        if (maxDimension > 0) {
            viewer->setScale(1.0f / maxDimension * 200); // Масштабирование для полного отображения
        }
        return true;
    } else {
        QMessageBox::critical(this, "Ошибка", "Не удалось загрузить модель.");
        return false;
    }
}

QVector3D ModelViewer::getModelDimensions() const {
    return model->getModelDimensions();
}

double ModelViewer::calculateVolume() const {
    return model->calculateVolume();
}

double ModelViewer::calculateProjectionArea() const {
    return model->calculateProjectionArea();
}


4.1 modelviewer.h
#ifndef MODELVIEWER_H
#define MODELVIEWER_H

#include <QWidget>
#include "model.h"
#include "viewer.h"

class ModelViewer : public QWidget
{
    Q_OBJECT

public:
    ModelViewer(QWidget *parent = nullptr);
    bool loadModel(const QString &filePath);

    QVector3D getModelDimensions() const;
    double calculateVolume() const;
    double calculateProjectionArea() const;

private:
    Model *model;
    Viewer *viewer;
};

#endif // MODELVIEWER_H



5. viewer.cpp
#include "viewer.h"
#include <QPainter>
#include <QPen>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QFontMetrics>

Viewer::Viewer(QWidget *parent)
    : QWidget(parent), model(nullptr), rotationX(0), rotationY(0), scale(1.0)
{
    setMinimumSize(400, 400);
}

void Viewer::setModel(Model *model)
{
    this->model = model;
    update();
}

void Viewer::setScale(float scale)
{
    this->scale = scale;
    update();
}

void Viewer::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    if (!model) {
        painter.drawText(rect(), Qt::AlignCenter, "Модель не загружена");
        return;
    }

    // Отрисовка модели
    const QVector<QVector3D> &vertices = model->getVertices();
    const QVector<QVector<int>> &faces = model->getFaces();

    painter.setPen(QPen(Qt::black, 2));
    for (const QVector3D &vertex : vertices) {
        float x = vertex.x() * cos(rotationY) - vertex.z() * sin(rotationY);
        float z = vertex.x() * sin(rotationY) + vertex.z() * cos(rotationY);
        float y = vertex.y() * cos(rotationX) - z * sin(rotationX);
        z = vertex.y() * sin(rotationX) + z * cos(rotationX);

        QPointF point((x * scale) + width() / 2, height() / 2 - (y * scale));
        painter.drawEllipse(point, 3, 3);
    }

    painter.setPen(QPen(Qt::blue, 2));
    for (const QVector<int> &face : faces) {
        if (face.size() < 3) continue;
        QPolygonF polygon;
        for (int index : face) {
            const QVector3D &vertex = vertices[index];
            float x = vertex.x() * cos(rotationY) - vertex.z() * sin(rotationY);
            float z = vertex.x() * sin(rotationY) + vertex.z() * cos(rotationY);
            float y = vertex.y() * cos(rotationX) - z * sin(rotationX);
            z = vertex.y() * sin(rotationX) + z * cos(rotationX);

            QPointF point((x * scale) + width() / 2, height() / 2 - (y * scale));
            polygon << point;
        }
        painter.drawPolygon(polygon);
    }

    // Вывод информации о модели в столбик
    QVector3D dimensions = model->getModelDimensions();
    double volume = model->calculateVolume();
    double area = model->calculateProjectionArea();

    // Форматирование текста
    QStringList infoLines;
    infoLines << "Размеры модели:";
    infoLines << QString("X: %1 м").arg(dimensions.x(), 0, 'f', 2);
    infoLines << QString("Y: %1 м").arg(dimensions.y(), 0, 'f', 2);
    infoLines << QString("Z: %1 м").arg(dimensions.z(), 0, 'f', 2);
    infoLines << ""; // Пустая строка для разделения
    infoLines << QString("Объем: %1 м³").arg(volume, 0, 'f', 2);
    infoLines << ""; // Пустая строка для разделения
    infoLines << QString("Площадь проекции: %1 м²").arg(area, 0, 'f', 2);

    // Установка шрифта и цвета
    painter.setPen(Qt::black);
    painter.setFont(QFont("Arial", 10));

    // Вывод текста в столбик
    int lineHeight = painter.fontMetrics().height();
    int yOffset = 20; // Начальная позиция по вертикали
    for (const QString &line : infoLines) {
        painter.drawText(10, yOffset,
                         line); // Вывод каждой строки
                                yOffset += lineHeight; // Смещение вниз на высоту строки
                            }
                        }

                        void Viewer::mousePressEvent(QMouseEvent *event)
                        {
                            lastMousePosition = event->pos();
                        }

                        void Viewer::mouseMoveEvent(QMouseEvent *event)
                        {
                            if (event->buttons() & Qt::LeftButton) {
                                rotationX += (event->y() - lastMousePosition.y()) * 0.5;
                                rotationY += (event->x() - lastMousePosition.x()) * 0.5;
                                lastMousePosition = event->pos();
                                update();
                            }
                        }

                        void Viewer::wheelEvent(QWheelEvent *event)
                        {
                            // Масштабирование модели
                            if (event->angleDelta().y() > 0) {
                                scale *= 1.1; // Увеличение масштаба
                            } else {
                                scale /= 1.1; // Уменьшение масштаба
                            }
                            update();
                        }

5.1 viewer.h
#ifndef VIEWER_H
#define VIEWER_H

#include <QWidget>
#include "model.h"

class Viewer : public QWidget
{
    Q_OBJECT

public:
    Viewer(QWidget *parent = nullptr);
    void setModel(Model *model);
    void setScale(float scale); // Новый метод для установки масштаба

    void paintEvent(QPaintEvent *event) override;

protected:
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void wheelEvent(QWheelEvent *event) override;

private:
    Model *model;
    QPoint lastMousePosition;
    float rotationX;
    float rotationY;
    float scale; // Переменная для хранения масштаба
};

#endif // VIEWER_H


Структура программы:
My3DModelViewer/
├── CMakeLists.txt
├── main.cpp
├── model.h
├── model.cpp
├── viewer.h
├── viewer.cpp
├── modelviewer.h
├── modelviewer.cpp
├── mainwindow.h
└── mainwindow.cpp

Доработай программу: 1. Убери результаты расчета из окна программы слева. Оставь только в верхней части рамки, возле названия проекта 2. Добавь отображение названия модели obj, которая открыта в данный момент. 3. При повторном открытии другой модели obj в окне просмотра некорректно отображается модель. Остаются следы предыдущей открытой модели. Нужно это исправить. 4. Сделай возможность выделять текст на экране курсором и копирования в буфер обмена. Добавь возможность сохранения текста в блокнот. Отобрази измененные файлы программы, каждый файл отдельным сообщением. 
